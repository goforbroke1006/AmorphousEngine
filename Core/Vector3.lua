---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by goforbroke.
--- DateTime: 12/30/23 10:31 AM
---

require 'math'

Vector3 = { x = 0.0, y = 0.0, z = 0.0 }

function Vector3:new(newX --[[number]], newY --[[number]], newZ --[[number]])
    if type(newX) ~= "number"
            or type(newY) ~= "number"
            or type(newZ) ~= "number"
    then
        error("Can not create Vector3")
    end

    vec = {}
    self.__index = self
    setmetatable(vec, self)

    vec.x = newX
    vec.y = newY
    vec.z = newZ

    return vec
end

Vector3.zero = Vector3:new(0.0, 0.0, 0.0)

Vector3.forward = Vector3:new(0.0, 0.0, 1.0)
Vector3.back = Vector3:new(0.0, 0.0, -1.0)
Vector3.up = Vector3:new(0.0, 1.0, 0.0)
Vector3.down = Vector3:new(0.0, -1.0, 0.0)
Vector3.right = Vector3:new(1.0, 0.0, 0.0)
Vector3.left = Vector3:new(-1.0, 0.0, 0.0)

function Vector3:magnitude()
    return math.sqrt(
            math.pow(self.x, 2) + math.pow(self.y, 2) + math.pow(self.z, 2)
    )
end

function Vector3:normalized()
    local magnitude = self:magnitude()

    if (magnitude == 0.0) then
        return Vector3.zero
    end

    local nv = Vector3:new(
            self.x / magnitude,
            self.y / magnitude,
            self.z / magnitude
    )
    return nv
end

function Vector3:Set(newX --[[number]], newY --[[number]], newZ --[[number]])
    if type(newX) ~= "number"
            or type(newY) ~= "number"
            or type(newZ) ~= "number"
    then
        error("Can not set Vector3")
    end

    self.x = newX
    self.y = newY
    self.z = newZ
end

function Vector3:Distance(other --[[Vector3]])
    return math.sqrt(
            math.pow(self.x - other.x, 2) + math.pow(self.y - other.y, 2) + math.pow(self.z - other.z, 2)
    )
end

function Vector3:Normalize()
    local magnitude = self:magnitude()

    if (magnitude ~= 0.0) then
        self.x = self.x / magnitude
        self.y = self.y / magnitude
        self.z = self.z / magnitude
    end
end

function Vector3:ToString()
    return '(' .. self.x .. ', ' .. self.y .. ', ' .. self.z .. ')'
end

Vector3.__add = function(op1 --[[Vector3]], op2 --[[Vector3]])
    local vec = Vector3:new(
            op1.x + op2.x,
            op1.y + op2.y,
            op1.z + op2.z
    )

    return vec
end

Vector3.__sub = function(op1 --[[Vector3]], op2 --[[Vector3]])
    local vec = Vector3:new(
            op1.x - op2.x,
            op1.y - op2.y,
            op1.z - op2.z
    )

    return vec
end

function scale_vector(origin --[[Vector3]], alpha --[[number]])
    local vec = Vector3:new(
            origin.x * alpha,
            origin.y * alpha,
            origin.z * alpha
    )
    return vec
end

Vector3.__mul = function(op1, op2)
    if type(op2) == "number" then
        return scale_vector(op1, op2)
    elseif type(op1) == "number" then
        return scale_vector(op2, op1)
    else
        error("Can not scale by non-number factor")
    end
end
